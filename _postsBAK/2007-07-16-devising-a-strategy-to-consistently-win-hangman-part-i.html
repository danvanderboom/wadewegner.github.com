--- 
layout: post
title: "Devising a strategy to (consistently) win Hangman: Part I"
categories: 
- .NET 2.0
- Off topic
tags: []

status: publish
type: post
published: true
meta: 
  _edit_last: "1"
  _sexybookmarks_shortUrl: http://bit.ly/cp3AOy
  _sexybookmarks_permaHash: 92aa2c6818cf608122f8496dea610bc5
  dsq_thread_id: "609466396"
---
<p>Edit: Try my own version of <a href="http://apps.wadewegner.com/hangman/">Hangman</a>, written with Silverlight and WPF!</p>
<p>In an effort to distract myself from more productive endeavors, I started playing Hangman on <a href="http://www.thefreedictionary.com/">The Free Dictionary</a> Web site today.&nbsp; They have an outstanding plugin that you can also add to your Google homepage (which is actually how I discovered it).&nbsp; The interface allows you to simply type the letter into the guess box (if you look below you'll see that my last guess was the letter "G"), and it updates it as you go:</p>
<p><img style="BORDER-TOP-WIDTH: 0px; BORDER-LEFT-WIDTH: 0px; BORDER-BOTTOM-WIDTH: 0px; BORDER-RIGHT-WIDTH: 0px" height=136 alt=image src="http://images.wadewegner.com/wordpress/content/binary/WindowsLiveWriter/Devisingastrategytoconsistentlywinningha_1117F/image_2.png" width=404 border=0> </p>
<p>During game play, the plugin constructs the man you are desperately trying to save.&nbsp; You can only make ten mistakes before the man is hanged:</p>
<p><img style="BORDER-TOP-WIDTH: 0px; BORDER-LEFT-WIDTH: 0px; BORDER-BOTTOM-WIDTH: 0px; BORDER-RIGHT-WIDTH: 0px" height=147 alt=image src="http://images.wadewegner.com/wordpress/content/binary/WindowsLiveWriter/Devisingastrategytoconsistentlywinningha_1117F/image_4.png" width=406 border=0> </p>
<p>So, as I was wasting my time today, I started wondering if there's a strategy to winning Hangman.&nbsp; Assuming that there is, I decided to try and figure it out.</p>
<p>I started with a few basic ideas:</p>
<ol>
<li>Certain letters are used more frequently than other letters.
<li>The frequency of letters are probably different given the total number of letters in the word.
<li>You can maximize your ability to win Hangman by playing the most common letter first, followed by the next most common letter, and so on.</li></ol>
<p>I realize that there are probably more complicated theories (such as the most common letters changing based on discovered letters), but for this first part I decided that I wanted to keep it somewhat simple.&nbsp; I can complicate it more later on.</p>
<p><strong><u>(If you aren't interested in <em>how</em> I explored these ideas than jump to the end of this post to see my findings!)</u></strong></p>
<p>My first order of business was to find a list of English words.&nbsp; After performing a few searches, I found what I was looking for: <a href="http://www.word-list.com/">Word-List.com</a>.&nbsp; They have word lists in many languages, and the lists are available as zipped text files separated by a newline.&nbsp; This made it very easy to parse.</p>
<p>I unzipped the file and added it to a new Visual Studio 2005 Console Application project.&nbsp; So that the file is always available in the root of the folder, I changed the <strong>Copy to Output Directory</strong> property to <strong>Copy always</strong>.&nbsp; Next, I wrote a method that loads all the words into a string array and saves&nbsp;each word to a particular file, based on the length of the word.&nbsp; For example, the words "dog" and "cat" are saved to the file "03.txt" whereas the words "father" and "mother" are saved to the file "06.txt".&nbsp; Here's the code:</p><pre class=code><span style="COLOR: rgb(0,0,255)">using</span> (<span style="COLOR: rgb(43,145,175)">StreamReader</span> input = <span style="COLOR: rgb(0,0,255)">new</span> <span style="COLOR: rgb(43,145,175)">StreamReader</span>(<span style="COLOR: rgb(163,21,21)">"words.english.txt"</span>))
{
    <span style="COLOR: rgb(0,0,255)">string</span> contents = input.ReadToEnd().Trim();
    <span style="COLOR: rgb(0,0,255)">string</span>[] wordArray = contents.Split(<span style="COLOR: rgb(163,21,21)">'n'</span>);

    <span style="COLOR: rgb(0,0,255)">foreach</span> (<span style="COLOR: rgb(0,0,255)">string</span> word <span style="COLOR: rgb(0,0,255)">in</span> wordArray)
    {
        appendWord(word);
    }
}</pre><a href="http://11011.net/software/vspaste"></a>
<p>Using the StreamReader, I loaded the file and split it into a string array based on the character 'n' (note the single, rather than double, quotes).&nbsp; This allows me to iterate through an array of words.&nbsp; I pass each word to the appendWord method, which calls the appendFile method.&nbsp; Passed in is a file name that's based on the length of the word, as well as the word itself.</p><pre class=code><span style="COLOR: rgb(0,0,255)">private</span> <span style="COLOR: rgb(0,0,255)">static</span> <span style="COLOR: rgb(0,0,255)">string</span> wordByLength = <span style="COLOR: rgb(163,21,21)">"{0}.txt"</span>;</pre><pre class=code><span style="COLOR: rgb(0,0,255)">public</span> <span style="COLOR: rgb(0,0,255)">static</span> <span style="COLOR: rgb(0,0,255)">void</span> appendWord(<span style="COLOR: rgb(0,0,255)">string</span> word)
{
    appendFile(<span style="COLOR: rgb(43,145,175)">String</span>.Format(wordByLength, word.Length.ToString().PadLeft(2, <span style="COLOR: rgb(163,21,21)">'0'</span>)), word);
}</pre>
<p>The appendFile method simply creates an instance of a StreamWriter and appends the word to the file (if it exists) or creates a new file (if it doesn't exist).</p><pre class=code><span style="COLOR: rgb(0,0,255)">public</span> <span style="COLOR: rgb(0,0,255)">static</span> <span style="COLOR: rgb(0,0,255)">void</span> appendFile(<span style="COLOR: rgb(0,0,255)">string</span> file, <span style="COLOR: rgb(0,0,255)">string</span> text)
{
    <span style="COLOR: rgb(0,0,255)">using</span> (<span style="COLOR: rgb(43,145,175)">StreamWriter</span> writer = <span style="COLOR: rgb(43,145,175)">File</span>.AppendText(file))
    {
        writer.WriteLine(text);
        writer.Flush();
    }
}</pre><a href="http://11011.net/software/vspaste"></a>
<p>Once I wrote all this and let it run, it took about 20-30 minutes to complete (I don't know exactly because I went to eat dinner).&nbsp; When I cam back, I had a directory of 23 files filed with sorted and ordered data:</p>
<p><img style="BORDER-RIGHT: 0px; BORDER-TOP: 0px; BORDER-LEFT: 0px; BORDER-BOTTOM: 0px" height=469 alt=image src="http://images.wadewegner.com/wordpress/content/binary/WindowsLiveWriter/Devisingastrategytoconsistentlywinningha_1117F/image_3.png" width=640 border=0>&nbsp;</p>
<p>Pretty cool, but not quite there!</p>
<p>Before I moved on, I wanted to know how many words had only two characters, three characters, and so on, all the way to 24.&nbsp; So, I wrote another method that loaded each of the aforementioned files, loaded them into an array,&nbsp;and determined the length of the array.</p><pre class=code><span style="COLOR: rgb(0,0,255)">foreach</span> (<span style="COLOR: rgb(0,0,255)">string</span> fileByLength <span style="COLOR: rgb(0,0,255)">in</span> <span style="COLOR: rgb(43,145,175)">Directory</span>.GetFiles(wordByLengthDirectory))
{
    <span style="COLOR: rgb(0,0,255)">using</span> (<span style="COLOR: rgb(43,145,175)">StreamReader</span> input = <span style="COLOR: rgb(0,0,255)">new</span> <span style="COLOR: rgb(43,145,175)">StreamReader</span>(fileByLength))
    {
        <span style="COLOR: rgb(0,0,255)">string</span> contents = input.ReadToEnd().Trim().Replace(<span style="COLOR: rgb(163,21,21)">"rn"</span>, <span style="COLOR: rgb(163,21,21)">"n"</span>);
        <span style="COLOR: rgb(0,0,255)">string</span>[] wordArray = contents.Split(<span style="COLOR: rgb(163,21,21)">'n'</span>);
        <span style="COLOR: rgb(0,0,255)">int</span> wordLength = wordArray[0].Length;

        appendFile(wordCountByLength, wordLength.ToString().PadLeft(2, <span style="COLOR: rgb(163,21,21)">'0'</span>) + <span style="COLOR: rgb(163,21,21)">": "</span> + wordArray.Length);
    }
}</pre><a href="http://11011.net/software/vspaste"></a>
<p>Nothing really complicated here.&nbsp; I loaded the files into a file array by using the Directory.GetFiles() method, replaced "rn" with "n" since the Environment.NewLine creates carriage return and a newline, split the array, and appended the length of the array (along with the number of characters in the word) into a file.&nbsp; Here were the results:</p>
<p><font face="Courier New">02: 61<br />03: 627<br />04: 2988<br />05: 7198<br />06: 14163<br />07: 20452<br />08: 27015<br />09: 29824<br />10: 29220<br />11: 25021<br />12: 19966<br />13: 14683<br />14: 9672<br />15: 5890<br />16: 3363<br />17: 1808<br />18: 838<br />19: 428<br />20: 197<br />21: 81<br />22: 40<br />23: 17<br />24: 5</font>
<p>Kind of interesting that there are more 9-letter words than any other words, eh?&nbsp; It also makes a really pretty looking graph:</p>
<p><img src="http://images.wadewegner.com/wordpress/content/binary/graph1.gif" border=0></p>
<p>While it's interesting, it doesn't really help me with my stated goal.</p>
<p>So, with the twenty-three independent files, I decided to find the most common letters, and sort them according to popularity.&nbsp; This, my friends, is the best part.&nbsp; Not only did I decide to use a generic list to contain the details of these files, but I also decided to use predicates and delegates to help me with my task!&nbsp; What fun!?!</p>
<p>First, I needed a collection to start the characters and counts in.&nbsp; For example, when I load the 61 words that contain two characters, I need a collection that keeps track of the frequency each character is used.&nbsp; To do this I defined a class called CharacterCounter, and then created a generic list.&nbsp; First, here's the class I created.</p><pre class=code><span style="COLOR: rgb(0,0,255)">public</span> <span style="COLOR: rgb(0,0,255)">class</span> <span style="COLOR: rgb(43,145,175)">CharacterCounter</span><span style="COLOR: rgb(43,145,175)">
</span>{
    <span style="COLOR: rgb(0,0,255)">private</span> <span style="COLOR: rgb(0,0,255)">char</span> character;
    <span style="COLOR: rgb(0,0,255)">private</span> <span style="COLOR: rgb(0,0,255)">int</span> count;

    <span style="COLOR: rgb(0,0,255)">public</span> <span style="COLOR: rgb(0,0,255)">char</span> Character
    {
        <span style="COLOR: rgb(0,0,255)">get</span> { <span style="COLOR: rgb(0,0,255)">return</span> character; }
        <span style="COLOR: rgb(0,0,255)">set</span> { character = <span style="COLOR: rgb(0,0,255)">value</span>; }
    }

    <span style="COLOR: rgb(0,0,255)">public</span> <span style="COLOR: rgb(0,0,255)">int</span> Count
    {
        <span style="COLOR: rgb(0,0,255)">get</span> { <span style="COLOR: rgb(0,0,255)">return</span> count; }
        <span style="COLOR: rgb(0,0,255)">set</span> { count = <span style="COLOR: rgb(0,0,255)">value</span>; }
    }
}</pre><a href="http://11011.net/software/vspaste"></a>
<p>Very simple class.&nbsp; It has two public properties: Character and Count.&nbsp; When used as a generic list, it allows me to create an object of characters with their associated counts (e.g. frequency used).</p>
<p>In determining the frequency each character is used based on the number of characters in the words, I first iterate through each of the files that contain the sorted words.&nbsp; This allows me to first find the ordered frequency of characters for words with two characters all the way to twenty-four characters.&nbsp; I then load the contents of each file into a string array, so that I can iterate through each of the words.&nbsp; Next, I create a character array out of the word, and iterate through each of the characters.&nbsp; It looks something like this:</p><pre class=code><span style="COLOR: rgb(0,0,255)">foreach</span> (<span style="COLOR: rgb(0,0,255)">string</span> fileByLength <span style="COLOR: rgb(0,0,255)">in</span> <span style="COLOR: rgb(43,145,175)">Directory</span>.GetFiles(wordByLengthDirectory))
{
    <span style="COLOR: rgb(43,145,175)">List</span>&lt;CharacterCounter&gt; characterCounters = <span style="COLOR: rgb(0,0,255)">new</span> <span style="COLOR: rgb(43,145,175)">List</span>&lt;CharacterCounter&gt;();
    <span style="COLOR: rgb(0,0,255)">int</span> fileLength = 0;

    <span style="COLOR: rgb(0,0,255)">using</span> (<span style="COLOR: rgb(43,145,175)">StreamReader</span> input = <span style="COLOR: rgb(0,0,255)">new</span> <span style="COLOR: rgb(43,145,175)">StreamReader</span>(fileByLength))
    {
        <span style="COLOR: rgb(0,0,255)">string</span> contents = input.ReadToEnd().Trim().Replace(<span style="COLOR: rgb(163,21,21)">"rn"</span>, <span style="COLOR: rgb(163,21,21)">"n"</span>);
        <span style="COLOR: rgb(0,0,255)">string</span>[] wordArray = contents.Split(<span style="COLOR: rgb(163,21,21)">'n'</span>);
        <span style="COLOR: rgb(0,0,255)">if</span> (fileLength == 0)
        {
            fileLength = wordArray[0].Length;
        }

        <span style="COLOR: rgb(0,0,255)">foreach</span> (<span style="COLOR: rgb(0,0,255)">string</span> word <span style="COLOR: rgb(0,0,255)">in</span> wordArray)
        {
            <span style="COLOR: rgb(0,0,255)">char</span>[] characterArray = word.ToCharArray();

            <span style="COLOR: rgb(0,0,255)">foreach</span> (<span style="COLOR: rgb(0,0,255)">char</span> character <span style="COLOR: rgb(0,0,255)">in</span> characterArray)
            {
                <span style="COLOR: rgb(0,128,0)">//...
</span>            }
        }
    }
}</pre><a href="http://11011.net/software/vspaste"></a>
<p>Once I am iterating through each of the characters, I need to start keeping track of the number of times the character appears.&nbsp; Notice that I created a generic list for my CharacterCounter class called characterCounters.&nbsp; Before I increment the character count, I first check to see if the character in question already exists within my list.&nbsp; This is performed using the following code:</p><pre class=code><span style="COLOR: rgb(43,145,175)">CharacterCounter</span> characterCounter = characterCounters.Find(<span style="COLOR: rgb(0,0,255)">delegate</span>(<span style="COLOR: rgb(43,145,175)">CharacterCounter</span> d)
{
    <span style="COLOR: rgb(0,0,255)">return</span> d.Character == character;
});</pre>
<p><a href="http://11011.net/software/vspaste"></a>If the character exists, then the characterCounter list returns the CharacterCounter object&nbsp;that has a Character that equals the character I specified.&nbsp; For instance, if the specified character is "a", and it exists in the CharacterCounter list, then the characterCounter object is returned with an "a" for the Character and the number of times it has been found in the Count property.</p>
<p>If the character does not exist in the characterCounters list, then the characterCounter object is null.&nbsp; If it's null, I create a new instance of a CharacterCounter, set my values accordingly, and add it to the list.&nbsp; If it's not null, I increment the count:</p><pre class=code><span style="COLOR: rgb(0,0,255)">if</span> (characterCounter == <span style="COLOR: rgb(0,0,255)">null</span>)
{
    characterCounter = <span style="COLOR: rgb(0,0,255)">new</span> <span style="COLOR: rgb(43,145,175)">CharacterCounter</span>();
    characterCounter.Character = character;
    characterCounter.Count = 1;

    characterCounters.Add(characterCounter);
}
<span style="COLOR: rgb(0,0,255)">else
</span>{
    characterCounter.Count += 1;
}</pre><a href="http://11011.net/software/vspaste"></a>
<p>This continues until I've gone through every word in the file.&nbsp; At this point, I have a generic CharacterCounter list filled with the number of times a character is found.&nbsp; Since I want to know the most commonly used characters, I need to sort my list so that the most common characters are first.</p>
<p>The following code will sort the characterCounters list by descending count:</p><pre>characterCounters.Sort(<span style="COLOR: rgb(0,0,255)">delegate</span>(<span style="COLOR: rgb(43,145,175)">CharacterCounter</span> cc0, <span style="COLOR: rgb(43,145,175)">CharacterCounter</span> cc1)<br />{<br />&nbsp;&nbsp;&nbsp; <span style="COLOR: rgb(0,0,255)">return</span> cc1.Count.CompareTo(cc0.Count);<br />});</pre>
<p>Using an anonymous delegate, you can tell the list to sort itself from the largest number to the smallest.&nbsp; Changing the code to the following will sort it from smallest to largest:</p><pre class=code>characterCounters.Sort(<span style="COLOR: rgb(0,0,255)">delegate</span>(<span style="COLOR: rgb(43,145,175)">CharacterCounter</span> cc0, <span style="COLOR: rgb(43,145,175)">CharacterCounter</span> cc1)
{
    <span style="COLOR: rgb(0,0,255)">return</span> cc0.Count.CompareTo(cc1.Count);
});</pre><a href="http://11011.net/software/vspaste"></a>
<p>All this is done <strong><u>without</u></strong> having to use the IComparable interface!&nbsp; Amazing!</p>
<p>At this point, our list is sorted.&nbsp; All we need to do is create a string based on the ordered characters, and write it to a file:</p><pre class=code><span style="COLOR: rgb(0,0,255)">foreach</span> (<span style="COLOR: rgb(43,145,175)">CharacterCounter</span> characterCounter <span style="COLOR: rgb(0,0,255)">in</span> characterCounters)
{
    orderedCharacters += characterCounter.Character.ToString();
}
appendFile(orderedFrequencyByLength, fileLength.ToString().PadLeft(2, <span style="COLOR: rgb(163,21,21)">'0'</span>) + <span style="COLOR: rgb(163,21,21)">": "</span> + orderedCharacters);</pre>
<p><a href="http://11011.net/software/vspaste"></a>The code simply iterates through the characterCounters list, appends the value of the Character property to a string, and then appends the data to a string.</p>
<p>After all of this work, we can finally show the list.&nbsp; </p>
<p><font face="courier new"># of characters in word: list of characters, from most frequent to least frequent</font></p>
<p><font face="courier new">02: aoueyidbrtfslnmhgwzkvjcp<br />03: aoeuirstdylmghpknbwfczvxj<br />04: aeoirutslndpkymbhgcwfzvjxq<br />05: aeriosnltuycdmhpbgkwfvzxjq<br />06: earinoltsucdmphgbykfwvzxjq<br />07: eairnoltsucdmpghbykfwvzxjq<br />08: eaironlstucdmphgybfkwvzxjq<br />09: eiarontslcudmphygbfkvwzxqj<br />10: eiaorntslcupdmhygbfvkwzxqj<br />11: eiaorntslcupmdhygbfvkwzxqj<br />12: eiaontrslcupmhdygbfvzkxwqj<br />13: eiaontrslcpumhdygbvfzxkqwj<br />14: eioantsrlcpuhmdygbvfzxqkwj<br />15: ieoantsrlcpuhmydgbvfzxqkwj<br />16: eioatnrslcphumydgbvfzxqkwj<br />17: ieoatnrsclphumydgbvfzxqkwj<br />18: oeiatrnsclphmuydgbvfzxqkjw<br />19: oiaetnrsclhpmyudgbvzfxqkwj<br />20: oieatrnlchspymugdbvzfxjqk<br />21: oietanlcrshpymgdubzfvjx<br />22: oeticrahnslpymdugbxvzjq<br />23: oiaetlhscnprmdyugbfx<br />24: oihletapcyrdsnfgmzux</font>
<p>Going from the left to the right, we can tell the frequency of a letter in a word based on the number of characters in the word.&nbsp; For example, in a nine-letter word, the most frequently used characters are: e, i, a, r, o, n, etc.</p>
<p>Now, here's the real question: does knowing all of this help us to be a better Hangman player?</p>
<p>Well, what don't you try for yourself.&nbsp; Go to <a href="http://www.thefreedictionary.com/">The Free Dictionary</a>&nbsp;and play a game of Hangman.&nbsp; Based on the number of characters in the word, try the list characters above in their given order.&nbsp; From what I've seen, it doesn't work 100% of the time, but it certainly gets it correct more often than not.</p>
<p>In Part II (goodness, a Part II?!?!), I plan to write a test framework that uses the dictionary I downloaded to randomly calculate the accuracy of this method.&nbsp; I'll use a large set of sample data, and see how often I can guess the word correctly based on the rules above without specifying ten incorrect answers.</p>
<p>In Part III (holy smokes!), I'd like to make the rules more intelligent by changing the most common letters used based on the known letters in the word.&nbsp; For instance, if the word has an S and T, I'd like to know if an E or I is more likely to also be in the word.</p>
<p>Chances are it'll be awhile before I get to Part II and Part III, but I think I'll get there eventually.</p>
<p>I truly hope that at least someone else out there has fond some value in this post!&nbsp; Here's the full source-code, along with all the parsed files (look in the debug directory).</p>
<p><a href="http://images.wadewegner.com/wordpress/content/binary/Dictionary.zip">Dictionary.zip (2.15 MB)</a></p>
<p>Please let me know if you have any thoughts!</p>
