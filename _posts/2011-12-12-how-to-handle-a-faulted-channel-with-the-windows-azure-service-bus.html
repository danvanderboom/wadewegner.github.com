--- 
layout: post
title: How to Handle a Faulted Channel with the Windows Azure Service Bus
categories: 
- Service Bus
- WCF
- Windows Azure
tags: []

status: publish
type: post
published: true
meta: 
  _topsy_long_url: http://www.wadewegner.com/2011/12/how-to-handle-a-faulted-channel-with-the-windows-azure-service-bus/
  topsy_short_url: http://bit.ly/sx52EZ
  dsq_thread_id: "609466641"
---
<p>Recently I wrote a WCF service that fronted an on-premises SQL Server database for an MVC application running in a <a href="http://www.windowsazure.com/en-us/home/tour/compute/" target="_blank">Window Azure Web Role</a>. There are a number of ways I could have approached this scenario; I decided to use the <a href="http://msdn.microsoft.com/en-us/library/windowsazure/microsoft.servicebus.nettcprelaybinding.aspx" target="_blank">netTcpRelayBinding</a> via the <a href="http://www.windowsazure.com/en-us/home/tour/service-bus/" target="_blank">Windows Azure Service Bus</a> for the following reasons:</p>  <ul>   <li>I needed optimal performance (i.e. TCP over HTTP). </li>    <li>I wanted to reuse existing connections (rather than opening many connections). </li>    <li>I didn’t want to open up ports in my firewall (inbound or outbound). </li> </ul>  <p>Based on these requirements, the Service Bus is almost a no brainer. The Service Bus provides both messaging and connectivity capabilities, the latter of which provide a nice way to build loosely coupled applications in hybrid scenarios (i.e. cloud + on-premises).</p>  <p>I dove right in and wrote the following code:</p>  <pre class="code"><span style="color: blue">public static </span><span style="color: #2b91af">IEnumerable</span>&lt;<span style="color: #2b91af">Customer</span>&gt; GetCustomers()
{
    <span style="color: #2b91af">Uri </span>serviceUri = <span style="color: #2b91af">ServiceBusEnvironment</span>.CreateServiceUri(<span style="color: #a31515">&quot;sb&quot;</span>, 
        <span style="color: #a31515">&quot;MYSERVICENAMESPACE&quot;</span>, <span style="color: #a31515">&quot;Customer&quot;</span>);
    <span style="color: blue">var </span>customersChannelFactory = <span style="color: blue">new </span><span style="color: #2b91af">ChannelFactory</span>&lt;<span style="color: #2b91af">ICustomerChannel</span>&gt;(
        <span style="color: #a31515">&quot;RelayEndpoint&quot;</span>, <span style="color: blue">new </span><span style="color: #2b91af">EndpointAddress</span>(serviceUri));
    <span style="color: blue">var </span>customersChannel = customersChannelFactory.CreateChannel();
    customersChannel.Open();

    <span style="color: blue">return </span>customersChannel.GetCustomers();
}</pre>


<p>(I put much of the binding, client, and endpoint behaviors in the Web.Config.)</p>

<p>This code works but has problems. The channel to the Service Bus will open every time the service is called, resulting in suboptimal performance. To make this more efficient I decided to make the <font face="Courier New">ChannelFactory</font> and <font face="Courier New">Channel</font> variables statics so that I could reuse the channel if it had already been opened.</p>

<pre class="code"><span style="color: blue">static </span><span style="color: #2b91af">ChannelFactory</span>&lt;<span style="color: #2b91af">ICustomerChannel</span>&gt; customersChannelFactory;
<span style="color: blue">static </span><span style="color: #2b91af">ICustomerChannel </span>customersChannel;

<span style="color: blue">public static </span><span style="color: #2b91af">IEnumerable</span>&lt;<span style="color: #2b91af">Customer</span>&gt; GetCustomers()
{
    <span style="color: blue">if </span>(customersChannelFactory == <span style="color: blue">null </span>|| customersChannel == <span style="color: blue">null</span>)
    {
        <span style="color: #2b91af">Uri </span>serviceUri = <span style="color: #2b91af">ServiceBusEnvironment</span>.CreateServiceUri(<span style="color: #a31515">&quot;sb&quot;</span>, 
            <span style="color: #a31515">&quot;MYSERVICENAMESPACE&quot;</span>, <span style="color: #a31515">&quot;Customer&quot;</span>);
        customersChannelFactory = <span style="color: blue">new </span><span style="color: #2b91af">ChannelFactory</span>&lt;<span style="color: #2b91af">ICustomerChannel</span>&gt;(
            <span style="color: #a31515">&quot;RelayEndpoint&quot;</span>, <span style="color: blue">new </span><span style="color: #2b91af">EndpointAddress</span>(serviceUri));
        customersChannel = customersChannelFactory.CreateChannel();
        customersChannel.Open();
    }

    <span style="color: blue">return </span>customersChannel.GetCustomers();
}</pre>


<p>This updated does a good job of improving the performance of the service call but has it’s own problems. When you create a <font face="Courier New">Channel</font> through the <font face="Courier New">ChannelFactory</font> your channel can enter a faulted state – with the Service Bus there are a number of ways that this can occur (in my testing it was because I often stopped/started the service host). When this happens the WCF communication static must be reset by recreating the client channel. </p>

<p>Finding an efficient – and somewhat elegant – way of handling the faulted state proved to be a fun challenge. Fortunately, I received a lot of help from folks on the Service Bus team.</p>

<p>In the end I went with the following code:</p>

<pre class="code"><span style="color: blue">static </span><span style="color: #2b91af">ChannelFactory</span>&lt;<span style="color: #2b91af">ICustomerChannel</span>&gt; customersChannelFactory;
<span style="color: blue">static </span><span style="color: #2b91af">ICustomerChannel </span>customersChannel;

<span style="color: blue">public static </span><span style="color: #2b91af">IEnumerable</span>&lt;<span style="color: #2b91af">Customer</span>&gt; GetCustomers()
{
    <span style="color: #2b91af">List</span>&lt;<span style="color: #2b91af">Customer</span>&gt; customers = <span style="color: blue">null</span>;

    <span style="color: blue">if </span>(customersChannelFactory == <span style="color: blue">null</span>)
    {
        <span style="color: #2b91af">Uri </span>serviceUri = <span style="color: #2b91af">ServiceBusEnvironment</span>.CreateServiceUri(<span style="color: #a31515">&quot;sb&quot;</span>, 
            <span style="color: #a31515">&quot;MYSERVICENAMESPACE&quot;</span>, <span style="color: #a31515">&quot;Customer&quot;</span>);
        customersChannelFactory = <span style="color: blue">new </span><span style="color: #2b91af">ChannelFactory</span>&lt;<span style="color: #2b91af">ICustomerChannel</span>&gt;(
            <span style="color: #a31515">&quot;RelayEndpoint&quot;</span>, <span style="color: blue">new </span><span style="color: #2b91af">EndpointAddress</span>(serviceUri));
    }

    <span style="color: blue">int </span>tries = 0;
    <span style="color: blue">while </span>(tries++ &lt; 3)
    {
        <span style="color: blue">try
        </span>{
            <span style="color: blue">if </span>(customersChannel == <span style="color: blue">null</span>)
            {
                customersChannel = customersChannelFactory.CreateChannel();
                customersChannel.Open();
            }

            <span style="color: blue">return </span>customersChannel.GetCustomers();
        }
        <span style="color: blue">catch </span>(<span style="color: #2b91af">CommunicationException</span>)
        {
            customersChannel.Abort();
            customersChannel = <span style="color: blue">null</span>;
        }
    }

    <span style="color: blue">return </span>customers;
}</pre>


<p>More verbose but much, much better.</p>

<p>The key is correctly handling the <font face="Courier New">CommunicationException</font>, aborting the channel, and setting the channel to null. Since we have retry logic via the while loop it will try again, determine that the channel is null, and re-open the channel.</p>

<p>There are certainly other ways to do this correctly. For example, you could decide to create a <a href="http://msdn.microsoft.com/en-us/library/bb350915.aspx" target="_blank">Faulted event handler</a>.</p>

<p>I hope this helps!</p>
